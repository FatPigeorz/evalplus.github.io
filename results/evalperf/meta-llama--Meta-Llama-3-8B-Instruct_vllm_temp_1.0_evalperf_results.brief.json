{"date": "2024-10-27 18:01", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 77.04079291937829, "dps_norm": 75.1570617360002, "pass@1": 43.69491525423729}, "eval": {"HumanEval/9": {"dps": 50.41009463722398, "dps_norm": 62.77777777777778, "pass@1": 32.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max = [max(numbers[:i+1]) if i == 0 else max(numbers[:i+1]) for i in range(len(numbers))]\n    return rolling_max", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\"\"\"\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = [max(numbers[:i+1]) for i in range(len(numbers))]\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = [max(numbers[:i+1]) for i in range(len(numbers))]\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment \n    in the sequence.\"\"\"\n    return [max(numbers[:i+1]) for i in range(len(numbers))]", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_until_now = float('-inf')\n    for num in numbers:\n        if num > max_until_now:\n            max_until_now = num\n        result.append(max_until_now)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n    \n    Args:\n        numbers (List[int]): List of integers.\n    \n    Returns:\n        List[int]: List of rolling maximum element found until given moment in the sequence.\n    \n    Example:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_val = float('-inf')\n    for i, num in enumerate(numbers):\n        if num > max_val:\n            max_val = num\n        result.append(max_val)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    return [max(numbers[:i+1]) for i in range(len(numbers))]", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\"\"\"\n    rolling_max_list = [max(numbers[:i+1]) for i in range(len(numbers))]\n    return rolling_max_list", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    max_so_far = numbers[0]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_val = float('-inf')\n    for num in numbers:\n        if num > max_val:\n            max_val = num\n        result.append(max_val)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\"\"\"\n    result = []\n    max_num = float('-inf')\n    for num in numbers:\n        if num > max_num:\n            max_num = num\n        result.append(max_num)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_seen = float('-inf')  # Initialize max_seen as negative infinity\n    for num in numbers:\n        result.append(max_seen := max(max_seen, num))  # Update max_seen and append to result\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = [max(numbers[:i+1]) for i in range(len(numbers))]\n    return rolling_max_list", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\"\"\"\n    return [max(numbers[:i+1]) for i in range(len(numbers))]", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    max_so_far = numbers[0]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n\n    Args:\n    numbers (List[int]): The input list of integers\n\n    Returns:\n    List[int]: A list of rolling maximum element found until given moment in the sequence\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_so_far = float('-inf')\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    max_so_far = numbers[0]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    return [max(numbers[:i+1]) for i in range(len(numbers))]", "matching_cluster_idx": 2}]}, "HumanEval/0": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 37.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n\n    Args:\n    numbers (List[float]): The list of floating point numbers\n    threshold (float): The maximum distance between two numbers to be considered \"close\"\n\n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than \n    given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than the given threshold.\n    \n    Args:\n    numbers: A list of floating point numbers\n    threshold: A floating point number, the maximum difference between two numbers to be considered close\n\n    Returns:\n    True if any two numbers are closer to each other than the threshold, False otherwise\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than given threshold.\"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    threshold (float): A given threshold.\n\n    Returns:\n    bool: Whether any two numbers are closer to each other than the given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n\n    Args:\n        numbers (List[float]): A list of float numbers.\n        threshold (float): The minimum distance between two numbers to be considered \"close\".\n\n    Returns:\n        bool: True if there are any two numbers closer than the threshold, False otherwise.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    \n    Args:\n    numbers (List[float]): A list of float numbers\n    threshold (float): A threshold value\n    \n    Returns:\n    bool: True if any two numbers in the list are closer to each other than the threshold, False otherwise\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    \n    Args:\n    numbers (List[float]): The list of floating point numbers to check.\n    threshold (float): The threshold value.\n\n    Returns:\n    bool: True if two numbers are closer than the given threshold, False otherwise.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers\n    threshold (float): The maximum allowed difference between two numbers to be considered \"close\"\n\n    Returns:\n    bool: True if there are two numbers that are closer than the threshold, False otherwise\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than given threshold.\"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 25.838607594936708, "dps_norm": 70.83333333333334, "pass@1": 35.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average |x - x_mean |\n    \n    Parameters:\n    numbers (List[float]): A list of float numbers\n    \n    Returns:\n    float: Mean Absolute Deviation\n    \"\"\"\n    # Calculate the mean of the list\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviation for each number from the mean\n    deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean of the deviations\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): The input list of floating point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    # Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]\n    1.0\n    \"\"\"\n    # Calculate mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Initialize sum of absolute deviations\n    sum_deviation = 0\n    \n    # Calculate sum of absolute deviations\n    for num in numbers:\n        sum_deviation += abs(num - mean)\n    \n    # Calculate Mean Absolute Deviation\n    mad = sum_deviation / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): The list of input numbers\n\n    Returns:\n        float: The mean absolute deviation\n    \"\"\"\n    if len(numbers) == 0:\n        return 0.0  # Return 0 when there are no numbers\n\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean) for num in numbers]\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average |x - x_mean|\n    \n    Args:\n    numbers (List[float]): A list of float numbers\n    Returns:\n    float: Mean Absolute Deviation\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the Mean Absolute Deviation\n    mad = sum([abs(n - mean) for n in numbers] ) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    \n    Args:\n    numbers (List[float]): The input list of float numbers.\n\n    Returns:\n    float: The Mean Absolute Deviation\n\n    Example:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]\n    1.0\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n\n    # Initialize sum for MAD calculation\n    mad_sum = 0\n\n    # Iterate through the list of numbers\n    for num in numbers:\n        # Calculate absolute difference from the mean and add to the sum\n        mad_sum += abs(num - mean)\n\n    # Calculate the Mean Absolute Deviation\n    mad = mad_sum / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n\n    MAD = average | x - x_mean |\n\n    :param numbers: A list of float numbers\n    :return: Mean Absolute Deviation\n    \"\"\"\n    mean = sum(numbers) / len(numbers)  # Calculate the mean\n    deviations = [abs(num - mean) for num in numbers]  # Calculate absolute deviations from the mean\n    return sum(deviations) / len(deviations)  # Calculate the average of these deviations", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    :param numbers: A list of float numbers\n    :return: Mean Absolute Deviation\n    \"\"\"\n    # First, calculate the mean\n    mean = sum(numbers) / len(numbers)\n\n    # Then, calculate the absolute deviations from the mean\n    deviations = [abs(num - mean) for num in numbers]\n\n    # Finally, return the mean of the absolute deviations\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation \n    around the mean of this dataset. Mean Absolute Deviation is the \n    average absolute difference between each element and a centerpoint \n    (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Calculate mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate absolute deviations\n    deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate Mean Absolute Deviation\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Parameters:\n    numbers (List[float]): A list of float numbers\n    \n    Returns:\n    float: The Mean Absolute Deviation\n    \"\"\"\n    mean = sum(numbers) / len(numbers)  # Calculate the mean\n    deviation = [abs(num - mean) for num in numbers]  # Calculate absolute deviation for each number\n    return sum(deviation) / len(deviation)  # Return the mean of absolute deviation", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    dev = [abs(num - mean) for num in numbers]\n    return sum(dev) / len(dev)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation \n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each \n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviation from the mean for each number\n    deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean of these deviations\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate Mean Absolute Deviation (MAD) of a given list of numbers\n    MAD = average |x - x_mean|\n    \"\"\"\n    # Calculate mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate absolute deviations\n    deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate MAD\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # First calculate the mean\n    mean = sum(numbers) / len(numbers)\n    # Calculate the mean absolute deviation\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate absolute deviations from the mean\n    deviations = [abs(num - mean) for num in numbers]\n\n    # Calculate mean of deviations\n    mad = sum(deviations) / len(deviations)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average |x - x_mean|\n    \n    Args:\n    numbers (List[float]): Input list of floating point numbers\n\n    Returns:\n    float: Mean Absolute Deviation\n    \"\"\"\n    # Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(deviations) / len(deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    :param numbers: A list of floating point numbers\n    :return: Mean Absolute Deviation (MAD) for the input numbers\n    \"\"\"\n    mean = sum(numbers) / len(numbers)  # Calculate the mean\n    deviations = [abs(num - mean) for num in numbers]  # Calculate the absolute deviations\n    return sum(deviations) / len(deviations)  # Calculate the average of the absolute deviations", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]\n    1.0\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviations\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    \n    return mad\nnumbers = [1.0, 2.0, 3.0, 4.0]", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate Mean Absolute Deviation around the mean of the dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each element\n    and the mean of the dataset.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation (MAD) of the input dataset.\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]\n    \"\"\"\n    mean = statistics.mean(numbers)\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    dev = [abs(num - mean) for num in numbers]\n    return sum(dev) / len(dev)", "matching_cluster_idx": 3}]}, "HumanEval/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    string = string.lower()  # convert the string to lowercase for case-insensitive comparison\n    return len(set(string))  # convert the string into a set and get its length", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(string.casefold()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(s: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(s.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.casefold()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(string.casefold()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\"\"\"\n    return len(set(string.casefold()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(s: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring the case.\n    \"\"\"\n    return len(set(s.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(char.lower() for char in set(string)))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(s: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(s.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.casefold()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 51.42484634010058, "dps_norm": 65.8119658119658, "pass@1": 13.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    result = None\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                result = (numbers[i], numbers[j])\n    return tuple(sorted(result))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_pair = ()\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n    \n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements\")\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = float('inf')\n    result = None\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                result = (numbers[i], numbers[j])\n    return tuple(sorted(result))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    result = ()\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i+1])\n        elif diff == min_diff:\n            if numbers[i+1] < result[1]:\n                result = (numbers[i], numbers[i+1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport itertools\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements\")\n\n    closest_pair = None\n    min_diff = float('inf')\n    for a, b in itertools.combinations(numbers, 2):\n        diff = abs(b - a)\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (a, b)\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = ()\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_distance = float('inf')\n    closest_pair = (None, None)\n    for i in range(len(numbers) - 1):\n        distance = numbers[i + 1] - numbers[i]\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements\")\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    \n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 21.08843537414966, "dps_norm": 12.5, "pass@1": 79.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    largest = 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            largest = i\n            break\n    return largest", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    divisor = 0\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            divisor = i\n            break\n    return divisor", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # return 1 if the input is a prime number", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}]}, "HumanEval/26": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/31": {"dps": 77.78481012658227, "dps_norm": 81.875, "pass@1": 72.0, "profiled": [{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5 + 1)\n    for d in range(3, max_divisor + 1, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    elif n == 2:  # 2 is the only even prime number\n        return True\n    elif n % 2 == 0:  # All other even numbers are not prime\n        return False\n    else:\n        max_divisor = int(n**0.5) + 1  # Only need to check up to the square root of n\n        for d in range(3, max_divisor, 2):\n            if n % d == 0:\n                return False\n        return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5 + 1)\n    for d in range(3, max_divisor):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(lst):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(lst))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 52.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            s = str(i)\n            count += s.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(2, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            for digit in str(i):\n                if digit == '7':\n                    count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            str_i = str(i)\n            count += str_i.count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            s = str(i)\n            count += s.count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 60.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics)\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics)\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Returns 2^n modulo p, being aware of numerical considerations.\n\n    Args:\n    n (int): Exponent\n    p (int): Base\n\n    Returns:\n    int: 2^n modulo p\n\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics)\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Returns 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    import math\n    if n < 0:\n        return modp(-n, p)  # Negative number simplification\n    if p == 0:  # No mod operation for division by zero!\n        raise ZeroDivisionError(\"Cannot divide by zero!\")\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 84.97584541062801, "dps_norm": 69.375, "pass@1": 55.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    This function takes a string as input and returns the string with all vowels removed.\n    \n    Parameters:\n    text (str): The input string.\n    \n    Returns:\n    str: The string with all vowels removed.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Removes all the vowels from a given text.\n    \n    Args:\n    text (str): The input string.\n    \n    Returns:\n    str: The text without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join(char for char in text if char.lower() not in 'aeiou')", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Remove all the vowels from a given string\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Remove all vowels from the input text and return the resulting string\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join(char for char in text if char.lower() not in 'aeiou')", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    This function takes a string and returns the string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    text = ''.join(char for char in text if char.lower() not in 'aeiou')\n    return text", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 42.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    return sorted(list(set1 & set2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    set1 = set(l1)\n    set2 = set(l2)\n    return sorted(list(set1 & set2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    set1 = set(l1)\n    set2 = set(l2)\n    return sorted(list(set1 & set2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1 & set2\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set_l1 = set(l1)\n    set_l2 = set(l2)\n    return sorted(list(set_l1.intersection(set_l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    Args:\n    l1 (list): The first list\n    l2 (list): The second list\n\n    Returns:\n    list: A sorted list of common elements in both input lists\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_set = set1 & set2\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1, l2):\n    set1 = set(l1)\n    set2 = set(l2)\n    return sorted(list(set1 & set2))", "matching_cluster_idx": 4}, {"solution": "def common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1 & set2  # Use set intersection\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1 & set2\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    set1 = set(l1)\n    set2 = set(l2)\n    return sorted(list(set1.intersection(set2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    set1 = set(l1) & set(l2)\n    return sorted(list(set1))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 62.2974537037037, "dps_norm": 71.29629629629629, "pass@1": 12.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(k: int) -> bool:\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if k <= 1:\n            return False\n        if k == 2:\n            return True\n        if k % 2 == 0:\n            return False\n        i = 3\n        while i * i <= k:\n            if k % i:\n                i += 2\n            else:\n                return False\n        return True\n\n    factors = [i for i in range(2, n) if n % i == 0]\n    return max((i for i in factors if is_prime(i)))", "matching_cluster_idx": 2}, {"solution": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    max_divisor = int(num**0.5 + 1)\n    for d in range(3, max_divisor, 2):\n        if num % d == 0:\n            return False\n    return True\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    factors = []\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            if is_prime(i):\n                return i\n    return 2", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if m is a prime number.\"\"\"\n        if m <= 1:\n            return False\n        if m <= 3:\n            return True\n        if m % 2 == 0 or m % 3 == 0:\n            return False\n        i = 5\n        while i * i <= m:\n            if m % i == 0 or m % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest = 1\n    for i in range(2, n):\n        if n % i == 0 and is_prime(i):\n            largest = i\n    return largest", "matching_cluster_idx": 1}, {"solution": "import doctest\ndef largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            for j in range(2, int(i/2) + 1):\n                if i % j == 0:\n                    break\n            else:\n                return i", "matching_cluster_idx": 2}, {"solution": "import doctest\ndef largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    def is_prime(m: int):\n        \"\"\"Check if m is a prime number\"\"\"\n        if m <= 1:\n            return False\n        if m <= 3:\n            return True\n        if m % 2 == 0 or m % 3 == 0:\n            return False\n        i = 5\n        while i * i <= m:\n            if m % i == 0 or m % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest = 1\n    for i in range(2, n):\n        if n % i == 0 and is_prime(i):\n            largest = i\n    return largest", "matching_cluster_idx": 2}, {"solution": "import doctest\ndef largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/74": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "HumanEval/85": {"dps": 73.53960396039604, "dps_norm": 50.833333333333336, "pass@1": 69.0, "profiled": [{"solution": "def add(lst):\n    return sum(x for x in lst[1::2] if x % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and isinstance(num, int) and num % 2 == 0)", "matching_cluster_idx": 1}, {"solution": "def add(lst):\n    sum_of_even_at_odd_indices = sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)\n    return sum_of_even_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and isinstance(num, int) and num % 2 == 0)", "matching_cluster_idx": 1}, {"solution": "def add(lst):\n    return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements at odd indices.\"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    result = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if element is even\n            result += lst[i]\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and type(x) == int and x % 2 == 0)", "matching_cluster_idx": 1}, {"solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(i for i in lst[1::2] if i % 2 == 0)", "matching_cluster_idx": 4}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(x for x in lst[1::2] if x % 2 == 0)", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 6.0, "profiled": []}, "HumanEval/87": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/89": {"dps": 91.82989690721651, "dps_norm": 27.857142857142858, "pass@1": 69.0, "profiled": [{"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    result = ''\n    for char in s:\n        if char.isalpha():\n            index = (alphabet.index(char.lower()) + 2 * 2) % 26\n            if char.isupper():\n                result += alphabet[index].upper()\n            else:\n                result += alphabet[index]\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[2*2:] + alphabet[:2*2]\n    output = \"\"\n    for char in s:\n        if char.isalpha():\n            if char.lower() in alphabet:\n                index = alphabet.index(char.lower())\n                if char.isupper():\n                    output += shifted_alphabet[index].upper()\n                else:\n                    output += shifted_alphabet[index]\n            else:\n                output += char\n        else:\n            output += char\n    return output", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            encrypted_char = chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n            result += encrypted_char\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2 * 2  # Shift the alphabet by 4 places\n    encrypted_string = ''\n    for char in s:\n        if char.isalpha():\n            char_index = alphabet.index(char.lower())\n            new_index = (char_index + shift) % len(alphabet)\n            if char.isupper():\n                encrypted_string += alphabet[new_index].upper()\n            else:\n                encrypted_string += alphabet[new_index]\n        else:\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for char in s:\n        if char.isalpha():\n            index = alphabet.index(char.lower())\n            result += alphabet[(index + 2 * 2) % 26]\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    # Get the English alphabet without spaces and punctuation\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2 * 2  # Shift down by 4 places\n    result = ''\n\n    for char in s:\n        if char.isalpha():\n            if char.lower() in alphabet:\n                index = alphabet.index(char.lower())\n                new_index = (index + shift) % len(alphabet)\n                if char.isupper():\n                    result += alphabet[new_index].upper()\n                else:\n                    result += alphabet[new_index]\n            else:\n                result += char\n        else:\n            result += char\n\n    return result", "matching_cluster_idx": 0}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[2*2:] + alphabet[:2*2]\n    result = ''\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result += shifted_alphabet[alphabet.index(char)]\n            else:\n                result += char\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    shift = 2 * 2\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    shifted_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    result = \"\"\n\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            shifted_result = chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n            result += shifted_result\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    s = s.lower()\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_string = ''\n    for char in s:\n        if char.isalpha():\n            index = alphabet.index(char.lower())\n            shifted_index = (index + 2 * 2) % 26\n            if char.isupper():\n                encrypted_string += alphabet[shifted_index].upper()\n            else:\n                encrypted_string += alphabet[shifted_index]\n        else:\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    result = ''\n    for char in s:\n        if char in alphabet:\n            index = alphabet.index(char)\n            new_index = (index + 4) % len(alphabet)\n            result += alphabet[new_index]\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            encrypted_char = chr((ord(char) + 2 * 2 - ascii_offset) % 26 + ascii_offset)\n            result += encrypted_char\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2*2\n    result = ''\n    for char in s:\n        if char.isalpha():\n            index = alphabet.index(char.lower())\n            if char.isupper():\n                result += alphabet[(index + shift) % 26].upper()\n            else:\n                result += alphabet[(index + shift) % 26]\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 87.82101167315176, "dps_norm": 60.833333333333336, "pass@1": 46.0, "profiled": [{"solution": "def next_smallest(lst):\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = sorted(set(lst))  # remove duplicates and sort the list\n    if len(lst) < 2:\n        return None  # return None if list has less than 2 elements\n    if lst[0] == lst[1]:  # if the smallest two elements are the same, return None\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(lst)\n    for i in range(len(sorted_lst)-1):\n        if sorted_lst[i] < sorted_lst[i+1]:\n            return sorted_lst[i+1]\n    return None", "matching_cluster_idx": 10}, {"solution": "def next_smallest(lst):\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in the list.\n    Returns None if the list has less than 2 elements or if all elements are the same.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    lst = set(lst)  # remove duplicates and sort the list\n    lst = sorted(lst)\n    if len(lst) > 1:\n        return lst[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = sorted(set(lst))  # remove duplicates and sort\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list. Returns None if there is no such element.\n    \"\"\"\n    lst = sorted(set(lst))  # remove duplicates and sort the list\n    if len(lst) < 2:\n        return None\n    return lst[1] if lst[0] == lst[1] else lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = list(set(lst))  # removing duplicates, preserving original order\n    if len(lst) < 2:\n        return None\n    lst.sort()\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = sorted(set(lst))  # remove duplicates and sort\n    if len(lst) < 2:\n        return None  # no 2nd smallest\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = sorted(set(lst))  # remove duplicates and sort the list\n    if len(lst) < 2:  # check if the list has less than two elements\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = sorted(set(lst))  # Remove duplicates and sort the list\n    if len(lst) < 2:\n        return None  # If the list has less than 2 elements, there's no 2nd smallest element\n    if lst[0] == lst[1]:  # If the list has the same elements, the 2nd smallest element doesn't exist\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = sorted(set(lst))\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    try:\n        # Sort the list to find the smallest and the second smallest elements\n        sorted_lst = sorted(set(lst))\n        \n        # Check if the list is empty or has only one element\n        if len(sorted_lst) < 2:\n            return None\n        \n        # Return the second smallest element\n        return sorted_lst[1]\n    except TypeError:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = sorted(set(lst))  # convert the list to a set and sort it\n    if len(lst) < 2:\n        return None\n    else:\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if not lst:\n        return None\n    elif len(set(lst)) == 1:\n        return None\n    else:\n        lst.sort()\n        for i in range(len(lst) - 1):\n            if lst[i] < lst[i+1]:\n                return lst[i+1]\n    return None", "matching_cluster_idx": 8}, {"solution": "def next_smallest(lst):\n    lst = sorted(set(lst))  # convert list to a set and sort\n    if len(lst) < 2:  # if the list has less than 2 unique elements, return None\n        return None\n    else:\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    try:\n        lst = sorted(set(lst))\n        return lst[1] if len(lst) > 1 else None\n    except TypeError:\n        return None", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/119": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "HumanEval/121": {"dps": 83.40807174887892, "dps_norm": 64.28571428571429, "pass@1": 41.0, "profiled": [{"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Return the sum of all of the odd elements that are in even positions in the list.\"\"\"\n    return sum(x for x in lst[::2] if x % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(i for i in lst[::2] if i % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum([num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(i for i in lst[::2] if i % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    \"\"\"\n    Returns the sum of all the odd elements at even positions in the list.\n    \"\"\"\n    return sum(x for x in lst[::2] if x % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    return sum(i for i in lst[::2] if i % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    total = 0\n    for i, num in enumerate(lst):\n        if i % 2 == 0 and num % 2 != 0:  # Check if the index is even and the number is odd\n            total += num\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    sum_odd_even_positions = 0\n    for i, num in enumerate(lst):\n        if i % 2 == 0 and num % 2 != 0:\n            sum_odd_even_positions += num\n    return sum_odd_even_positions", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 == 1)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 16.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    return sorted([x for x in lst if len(x) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([i for i in lst if len(i)%2==0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([x for x in lst if len(x) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([s for s in lst if len(s) % 2 == 0], key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([s for s in lst if len(s)%2==0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    lst = [i for i in lst if len(i) % 2 == 0]  # Filter out strings with odd length\n    return sorted(lst, key=lambda x: (len(x), x) )  # Sort list by length then alphabetically", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([i for i in lst if len(i) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([i for i in lst if len(i) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths and sort the remaining strings\n    result = sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))\n    return result", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([x for x in lst if len(x) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([x for x in lst if len(x)%2==0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 65.67796610169492, "dps_norm": 81.25, "pass@1": 78.0, "profiled": [{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not prime, otherwise return False\"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0:\n        return True\n    else:\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    if num < 2:\n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 87.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use a max heap to store the n largest numbers\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use a heap to store the n largest numbers\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    # Use heapq.nlargest to find the n largest elements\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(data, n):\n    return heapq.nlargest(n, data)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 50.34013605442177, "dps_norm": 50.0, "pass@1": 17.0, "profiled": [{"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    count = 0\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:]+s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    if len(set(s)) == 1:\n        return 1\n    else:\n        for i in range(1, len(s)):\n            if s == s[i:] + s[:i]:\n                return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:]+s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:]+s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:]+s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 28.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key = sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key = sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    matrix.sort(key=lambda x: sum(x))\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key = sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return (sorted(matrix, key=sum))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key = sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    sorted_matrix = sorted([[sum(row), row] for row in matrix])\n    return [row[1] for row in sorted(sorted_matrix)]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return [row for _, row in sorted((sum(row), row) for row in matrix)]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return (sorted(matrix, key = sum))", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/19": {"dps": 17.67676767676768, "dps_norm": 73.33333333333333, "pass@1": 17.0, "profiled": [{"solution": "def contains_duplicate(array):\n    return len(array) != len(set(array))\ndef test_duplicate(array):\n    return contains_duplicate(array)", "matching_cluster_idx": 10}, {"solution": "def find_duplicate(nums):\n    return len(nums) != len(set(nums))\ndef test_duplicate(input_list):\n    return find_duplicate(input_list)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(input_list):\n    return has_duplicates(input_list)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(lst):\n    return has_duplicates(lst)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(arr):\n    return has_duplicates(arr)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(arr):\n    return has_duplicates(arr)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(lst):\n    return len(lst) != len(set(lst))\ndef test_duplicate(lst):\n    return has_duplicates(lst)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(lst):\n    return len(lst) != len(set(lst))\ndef test_duplicate(lst):\n    return has_duplicates(lst)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(arr):\n    return has_duplicates(arr)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(lst):\n    return len(lst) != len(set(lst))\ndef test_duplicate(lst):\n    return has_duplicates(lst)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(arr):\n    return has_duplicates(arr)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(lst):\n    return len(lst) != len(set(lst))\ndef test_duplicate(lst):\n    return has_duplicates(lst)", "matching_cluster_idx": 10}, {"solution": "def has_duplicate(array):\n    return len(array) != len(set(array))\ndef test_duplicate(input):\n    return has_duplicate(input)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(nums):\n    return len(nums) != len(set(nums))\ndef test_duplicate(nums):\n    return has_duplicates(nums)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(lst):\n    return len(lst) != len(set(lst))\ndef test_duplicate(lst):\n    return has_duplicates(lst)", "matching_cluster_idx": 10}, {"solution": "def contains_duplicate(arr):\n    return len(arr) != len(set(arr))\ndef test_duplicate(input_list):\n    return contains_duplicate(input_list)", "matching_cluster_idx": 10}, {"solution": "def has_duplicates(lst):\n    return len(lst) != len(set(lst))\ndef test_duplicate(lst):\n    return has_duplicates(lst)", "matching_cluster_idx": 10}]}, "Mbpp/62": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 78.0, "profiled": [{"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 81.0, "profiled": [{"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    return [tup for tup in list_of_tuples if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = [t for t in lst if all(i % k == 0 for i in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_tuples, k):\n    return [t for t in list_tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 71.42156862745098, "dps_norm": 72.85714285714285, "pass@1": 58.0, "profiled": [{"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for num in lst:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in set(lst):\n        freq_dict[item] = lst.count(item)\n    return freq_dict", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in set(lst):\n        freq[item] = lst.count(item)\n    return freq", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in set(lst):\n        freq_dict[item] = lst.count(item)\n    return freq_dict", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in set(lst):\n        freq[item] = lst.count(item)\n    return freq", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for i in set(lst):\n        freq[i] = lst.count(i)\n    return freq", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 10.0, "profiled": [{"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(i) for i in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(input_list):\n    return max(len(word) for word in input_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 74.17682926829268, "dps_norm": 59.0, "pass@1": 29.0, "profiled": [{"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(input_list):\n    if not input_list:\n        return None\n    return min(input_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    if not tuples:\n        return None\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    return min(list_of_tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    if tuples:\n        return min(tuples, key=lambda x: x[1])[0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return [value[0] for value in sorted(lst, key=lambda x: x[1])][0]", "matching_cluster_idx": 1}]}, "Mbpp/96": {"dps": 8.333333333333334, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 74.0, "profiled": [{"solution": "def frequency_lists(lists):\n    frequency = {}\n    for lst in lists:\n        for num in lst:\n            if num in frequency:\n                frequency[num] += 1\n            else:\n                frequency[num] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for lst in lists:\n        for item in lst:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    freq = {}\n    for lst in lists:\n        for elem in lst:\n            if elem in freq:\n                freq[elem] += 1\n            else:\n                freq[elem] = 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for lst in list_of_lists:\n        for elem in lst:\n            if elem in frequency:\n                frequency[elem] += 1\n            else:\n                frequency[elem] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for lst in lists:\n        for element in lst:\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for inner_list in list_of_lists:\n        for item in inner_list:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for lst in lists:\n        for num in lst:\n            if num in frequency:\n                frequency[num] += 1\n            else:\n                frequency[num] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    freq_dict = {}\n    for lst in list_of_lists:\n        for item in lst:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for num in [i for sublist in lists for i in sublist]:\n        if num not in frequency:\n            frequency[num] = 0\n        frequency[num] += 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    flat_list = [item for sublist in lists for item in sublist]\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for lst in lists:\n        for item in lst:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for l in lists:\n        for element in l:\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    flat_list = [item for sublist in lists for item in sublist]\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for lst in list_of_lists:\n        for num in lst:\n            if num in frequency_dict:\n                frequency_dict[num] += 1\n            else:\n                frequency_dict[num] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for lst in lists:\n        for item in lst:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for list in lists:\n        for item in list:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for lst in lists:\n        for element in lst:\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 78.86363636363636, "dps_norm": 94.16666666666667, "pass@1": 92.0, "profiled": [{"solution": "def add_lists(list, tuple):\n    return (*tuple, *list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tuple1):\n    return tuple1 + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    return (*tuple1, *list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_append, existing_tuple):\n    return existing_tuple + tuple(list_to_append)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, list2):\n    return list2 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    return (*tuple1, *list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tup):\n    return (*tup, *list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(l, t):\n    t += tuple(l)\n    return t", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    return (*tuple1, *list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tuple1):\n    return (*tuple1, *list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, t):\n    return t + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tuple_obj):\n    return tuple_obj + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list, tuple1):\n    return tuple1 + tuple(list)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    return (*tuple1, *list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tup):\n    return tup + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/111": {"dps": 36.892307692307696, "dps_norm": 65.625, "pass@1": 22.0, "profiled": [{"solution": "def common_in_nested_lists(lists):\n    return set.intersection(*[set(lst) for lst in lists])", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    common = set(nested_lists[0])\n    for l in nested_lists[1:]:\n        common = common & set(l)\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    sets = [set(lst) for lst in nested_lists]\n    intersection = set.intersection(*sets)\n    return intersection\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    return set(flat_list).intersection(*map(set, nested_lists))", "matching_cluster_idx": 2}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    return set.intersection(*map(set, nested_lists))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    unique_elements = set(flat_list)\n    common_elements = set()\n    for element in unique_elements:\n        if all(element in sublist for sublist in lst):\n            common_elements.add(element)\n    return common_elements", "matching_cluster_idx": 3}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert nested lists to sets of sets for faster lookup\n    sets = [set(sublist) for sublist in nested_lists]\n    # Find the set of common elements by doing set intersection\n    return set.intersection(*sets)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # First, we convert each nested list to a set for efficient lookup\n    sets = [set(lst) for lst in nested_lists]\n    # The common elements are the elements that are present in all sets\n    common = set.intersection(*sets)\n    return common", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    result = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        result &= set(lst)\n    return list(result)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    result = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        result &= set(lst)\n    return list(result)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    set1 = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        set1 = set1 & set(lst)\n    return set1", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    unique_elements = set(flat_list)\n    common_elements = set(flat_list).intersection(*[set(sublist) for sublist in nested_lists])\n    return common_elements", "matching_cluster_idx": 2}, {"solution": "def common_in_nested_lists(nested_lists):\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    common_elements = set(flat_list)\n    for sublist in nested_lists:\n        common_elements &= set(sublist)\n    return list(common_elements)", "matching_cluster_idx": 3}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return set()\n\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    return set(flat_list).intersection(*[set(sublist) for sublist in nested_lists])", "matching_cluster_idx": 2}, {"solution": "def common_in_nested_lists(nested_lists):\n    sets = [set(lst) for lst in nested_lists]\n    return set.intersection(*sets)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    return set(flat_list).intersection(*[set(sublist) for sublist in nested_lists])", "matching_cluster_idx": 2}, {"solution": "def common_in_nested_lists(nested_lists):\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    return set(flat_list).intersection(*nested_lists)", "matching_cluster_idx": 3}, {"solution": "def common_in_nested_lists(nested_lists):\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    common = set(flat_list)\n    return set(flat_list).intersection(*[set(sublist) for sublist in nested_lists])\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 2}]}, "Mbpp/123": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 86.0, "profiled": [{"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n,words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]\nn = 3\nsentence = \"python is a programming language\"", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/130": {"dps": 79.55156950672647, "dps_norm": 70.0, "pass@1": 67.0, "profiled": [{"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return max(frequency_dict, key=frequency_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counter = Counter(lst)\n    return max(counter, key=counter.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return max(frequency_dict, key=frequency_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_frequency = max(frequency_dict.values())\n    max_item = [key for key, value in frequency_dict.items() if value == max_frequency][0]\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_freq = max(frequency.values())\n    max_item = [k for k, v in frequency.items() if v == max_freq][0]\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count_dict = Counter(lst)\n    return max(count_dict, key=count_dict.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return max(frequency_dict, key=frequency_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    c = Counter(lst)\n    return max(c, key=c.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return max(freq_dict, key=freq_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to hold the frequency of each number in the list\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    # Find the item with the maximum frequency\n    max_freq = max(frequency.values())\n    # Find the item with the maximum frequency\n    max_num = [k for k, v in frequency.items() if v == max_freq][0]\n    return max_num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    frequency_dict = {}\n    for item in nums:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_freq_item = max(frequency_dict, key=frequency_dict.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    frequency_dict = Counter(lst)\n    return max(frequency_dict, key=frequency_dict.get)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return max(freq_dict, key=freq_dict.get)", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/140": {"dps": 68.69565217391305, "dps_norm": 72.5, "pass@1": 68.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    return set(i for sublist in list_of_lists for i in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set(x for pair in lst for x in pair)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(iterable):\n    return set(i for sublist in iterable for i in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    flat_list = [x for sub_list in lst for x in sub_list]\n    return set(flat_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    return set(num for sublist in nested_list for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set(num for sublist in lst for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set(num for pair in lst for num in pair)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(iterable_list):\n    flattened = [element for sublist in iterable_list for element in sublist]\n    return set(flattened)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set(x for sub in lst for x in sub)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set(item for sublist in lst for item in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    result = set()\n    for l in lst:\n        result.update(l)\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lst):\n    return set(num for sub_lst in lst for num in sub_lst)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    result = set()\n    for sub_list in lst:\n        result.update(sub_list)\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    return set(num for sublist in nested_list for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(iterable):\n    flat_set = set()\n    for elements in iterable:\n        for element in elements:\n            flat_set.add(element)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set(i for t in lst for i in t)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set(val for sublst in lst for val in sublst)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(data):\n    flat_set = set()\n    for sublist in data:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lists):\n    flat_list = [i for sublist in lists for i in sublist]\n    return set(flat_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    return set(flat_list)", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 51.0, "profiled": [{"solution": "def find_even_pair(lst):\n    return sum(1 for i in range(len(lst)) for j in range(i+1, len(lst)) if (lst[i] ^ lst[j]) % 2 == 0)", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_pairs = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    result = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                result += 1\n    return result", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 79.0, "profiled": [{"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(input_list, start_index, end_index):\n    return sum(input_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 75.42635658914728, "dps_norm": 34.285714285714285, "pass@1": 77.0, "profiled": [{"solution": "def odd_values_string(s):\n    return ''.join([char for idx, char in enumerate(s) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([ch for idx, ch in enumerate(s) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(i for i in s[::2])", "matching_cluster_idx": 4}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    result = ''\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            result += c\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return \"\".join([c for i, c in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([char for i, char in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([c for i, c in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    return ''.join([c for i, c in enumerate(input_string) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([c for i, c in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = ''\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([char for i, char in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([char for i, char in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return ''.join([char for index, char in enumerate(s) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([c for i, c in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    return ''.join(c for i, c in enumerate(input_str) if i % 2 == 0)", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/240": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/251": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/256": {"dps": 58.43607305936073, "dps_norm": 55.0, "pass@1": 34.0, "profiled": [{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def isPrime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for i in range(num):\n        if isPrime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Count the number of prime numbers less than n\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    count = 0\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    primes = [True] * (n+1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p ** 2 <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n            p += 1\n        while p <= n and not primes[p]:\n            p += 1\n\n    return sum(1 for p in range(2, n) if primes[p])", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, int(k**0.5) + 1):\n            if k % i == 0:\n                return False\n        return True\n\n    return sum(1 for i in range(2, n) if is_prime(i))", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    count = 0\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 1:\n        return 0\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, int(i ** 0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return len(primes)", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of primes less than n\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def isPrime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(n):\n        if isPrime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        i = 3\n        while i * i <= num:\n            if num % i == 0:\n                return False\n            i += 2\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def isPrime(k):\n        if k<2: return False\n        for i in range(2,int(k**0.5)+1):\n            if k%i==0: return False\n        return True\n\n    return sum(1 for i in range(2,n) if isPrime(i))", "matching_cluster_idx": 8}]}, "Mbpp/265": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 40.0, "dps_norm": 71.66666666666667, "pass@1": 78.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = inv = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv += 1\n    return inv", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    if len(arr) <= 1:\n        return 0\n    inv_count = 0\n    left_half = arr[:len(arr)//2]\n    right_half = arr[len(arr)//2:]\n    inv_count += get_Inv_Count(left_half) + get_Inv_Count(right_half)\n    i = j = k = 0\n    while i < len(left_half) and j < len(right_half):\n        if left_half[i] <= right_half[j]:\n            arr[k] = left_half[i]\n            i += 1\n        else:\n            arr[k] = right_half[j]\n            inv_count += len(left_half) - i\n            j += 1\n        k += 1\n    while i < len(left_half):\n        arr[k] = left_half[i]\n        i += 1\n        k += 1\n    while j < len(right_half):\n        arr[k] = right_half[j]\n        j += 1\n        k += 1\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def mergeSort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_count = mergeSort(arr[:mid])\n        right, right_count = mergeSort(arr[mid:])\n        merged, merge_count = merge(left, right)\n        return merged, left_count + right_count + merge_count\n\n    def merge(left, right):\n        inv_count = 0\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    arr, count = mergeSort(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        m = len(arr) // 2\n        left, left_inv = merge_sort(arr[:m])\n        right, right_inv = merge_sort(arr[m:])\n        merged, inv = merge(left, right)\n        return merged, left_inv + right_inv + inv\n\n    def merge(left, right):\n        inv = 0\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] > right[j]:\n                merged.append(right[j])\n                j += 1\n                inv += len(left) - i\n            else:\n                merged.append(left[i])\n                i += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv\n\n    arr, inv = merge_sort(arr)\n    return inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n        merged, left_right_inv = merge(left, right)\n        return merged, left_inv + right_inv + left_right_inv\n    def merge(left, right):\n        merged = []\n        i, j, inv = 0, 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv += len(left) - i\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv\n    arr, inv = merge_sort(arr)\n    return inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 81.0344827586207, "dps_norm": 62.5, "pass@1": 12.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    products = [x * y for x in list1 for y in list2]\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    combinations = [(i, j) for i in list1 for j in list2]\n    combinations.sort(key=lambda x: x[0]*x[1], reverse=True)\n    return [i*j for i, j in combinations[:k]]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    products = [(i, j) for i in list1 for j in list2]\n    products.sort(key=lambda x: x[0]*x[1], reverse=True)\n    return [x[0]*x[1] for x in products[:n]]", "matching_cluster_idx": 2}, {"solution": "def large_product(lst1, lst2, n):\n    if n > len(lst1) or n > len(lst2):\n        return []\n    products = [a * b for a in lst1 for b in lst2]\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            products.append(product)\n    products.sort(reverse=True)\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    product = sorted([x * y for x in list1 for y in list2], reverse=True)\n    return product[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    sorted_products = sorted([x*y for x in list1 for y in list2], reverse=True)\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    result = sorted([a*b for a in list1 for b in list2], reverse=True)[:n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Combining two lists and multiply each pair of elements and store them in a list\n    products = [a * b for a in list1 for b in list2]\n    # Sort the list in descending order\n    products.sort(reverse=True)\n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, n):\n    # Combine elements from the lists to generate all possible product pairs\n    product_pairs = [(i, j) for i in lst1 for j in lst2]\n    # Sort the pairs in descending order based on the product of elements\n    product_pairs.sort(key=lambda x: x[0] * x[1], reverse=True)\n    # Select the top n products\n    return [i * j for i, j in product_pairs[:n]]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, k):\n    products = sorted([i*j for i in list1 for j in list2], reverse=True)\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(l1, l2, k):\n    products = sorted([a * b for a in l1 for b in l2], reverse=True)[:k]\n    return products", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    count_dict = {}\n    for char in s:\n        if char in count_dict:\n            count_dict[char] += 1\n        else:\n            count_dict[char] = 1\n\n    for char in s:\n        if count_dict[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    count = {}\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in s:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_frequency = {}\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    for char, frequency in char_frequency.items():\n        if frequency == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 76.0, "profiled": [{"solution": "def check_tuplex(t, target):\n    if target in t:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if a specified element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): Tuple to check.\n    element: Element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, target):\n    return target in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, target):\n    return target in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, target):\n    \"\"\"\n    This function checks whether a target element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to check.\n    target: The target element to search for.\n    \n    Returns:\n    bool: True if the target element exists in the tuple, False otherwise.\n    \"\"\"\n    return target in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, x):\n    \"\"\"\n    This function checks if an element 'x' exists within a given tuple 't'.\n\n    Args:\n    t (tuple): The input tuple\n    x: The element to be checked\n\n    Returns:\n    bool: True if 'x' exists in 't', False otherwise\n    \"\"\"\n    return x in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, elem):\n    return elem in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): A tuple containing any number of elements\n    element: The element to be searched in the tuple\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks if an element exists within a tuple.\n    \n    Args:\n        tuplex (tuple): A tuple of elements.\n        element: The element to be searched for in the tuple.\n        \n    Returns:\n        boolean: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n    \n    Args:\n        tuplex (tuple): Input tuple\n        element: Element to be checked within the tuple\n    Returns:\n        bool: True if the element is found in the tuple, False otherwise\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 91.30434782608695, "dps_norm": 88.88888888888889, "pass@1": 10.0, "profiled": [{"solution": "def overlapping(lst1, lst2):\n    return any(i in lst2 for i in lst1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in sequence seq1 exists in sequence seq2.\n    \n    Parameters:\n    seq1 (list): The first sequence to check.\n    seq2 (list): The second sequence to check against.\n    \n    Returns:\n    bool: Whether any value in seq1 exists in seq2.\n    \"\"\"\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    for i in list1:\n        if i in list2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    for item in sequence1:\n        if item in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(a, b):\n    return any(i in b for i in a)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 76.95473251028807, "dps_norm": 85.71428571428571, "pass@1": 90.0, "profiled": [{"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tuple_input):\n    return \"-\".join(map(str, tuple_input))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    delimiter = '-'\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter = '-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return \"-\".join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tuple_val):\n    return '-'.join(map(str, tuple_val))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(i) for i in t)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return \"-\".join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 95.46931407942239, "dps_norm": 98.0, "pass@1": 99.0, "profiled": [{"solution": "def extract_rear(tpl):\n    return [s[-1] for s in tpl]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [char for string in t for char in string[-1:]]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(indexed_tuple):\n    return [element[-1] for element in indexed_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(string_tuple):\n    return [s[-1] for s in string_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(lst):\n    return [x[-1] for x in lst]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(string_tuple):\n    return [string[-1] for string in string_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(lst):\n    return [s[-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(lst):\n    return [x[-1] for x in lst]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_str):\n    return [s[-1] for s in tuple_str]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [i[-1] for i in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_list):\n    return [s[-1] for s in tuple_list]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(string_tuple):\n    return [s[-1] for s in string_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_str):\n    return [s[-1] for s in tuple_of_str]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_str):\n    return [s[-1] for s in tuple_str]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 64.2603550295858, "dps_norm": 85.0, "pass@1": 76.0, "profiled": [{"solution": "def count_element_in_list(lst, target):\n    return sum(1 for sublist in lst for element in sublist if element == target)", "matching_cluster_idx": 2}, {"solution": "def count_element_in_list(lst, num):\n    return sum(1 for sublist in lst if num in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, target_element):\n    count = 0\n    for sublst in lst:\n        if target_element in sublst:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    return sum(1 for sublst in lst for i in sublst if i == elem)", "matching_cluster_idx": 2}, {"solution": "def count_element_in_list(list_of_lists, target_element):\n    return sum(1 for lst in list_of_lists for element in lst if element == target_element)", "matching_cluster_idx": 2}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublst in lst for val in sublst if val == element)", "matching_cluster_idx": 2}, {"solution": "def count_element_in_list(lists, element):\n    return sum(1 for lst in lists if element in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sub_list in lst:\n        if element in sub_list:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, target):\n    return sum(1 for sublist in lst for element in sublist if element == target)", "matching_cluster_idx": 2}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for item in lst if isinstance(item, list) and element in item)", "matching_cluster_idx": 3}, {"solution": "def count_element_in_list(list_of_lists, target_element):\n    return sum(1 for sublist in list_of_lists if target_element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sub_list in lst for val in sub_list if val == element)", "matching_cluster_idx": 2}, {"solution": "def count_element_in_list(lst, target_element):\n    return sum(1 for sublst in lst for element in sublst if element == target_element)", "matching_cluster_idx": 2}]}, "Mbpp/428": {"dps": 81.36363636363636, "dps_norm": 55.0, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    def shell_sort_helper(arr, gap):\n        for i in range(gap, len(arr)):\n            key = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > key:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = key\n    gap = len(arr) // 2\n    while gap > 0:\n        shell_sort_helper(arr, gap)\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 63.82978723404255, "dps_norm": 60.0, "pass@1": 17.0, "profiled": [{"solution": "def check_greater(arr, num):\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    return all(x < n for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(nums, num):\n    return all(num > x for x in nums)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > i for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(lst, num):\n    return all(num > i for i in lst)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > i for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > i for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(nums, num):\n    return not any(num <= x for x in nums)", "matching_cluster_idx": 2}, {"solution": "def check_greater(lst, num):\n    return all(num > x for x in lst)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return not any(num <= x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    return all(i < n for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return not any(num <= i for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    return all(i < n for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 16.354679802955665, "dps_norm": 40.0, "pass@1": 10.0, "profiled": [{"solution": "def count_Occurrence(t, li):\n    return sum(1 for elem in li for e in t if e == elem)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(1 for x in tup for y in lst if x == y)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(lst, element_list):\n    return sum(1 for elem in lst for e in element_list if elem == e)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    return sum(1 for x in input_list for item in input_tuple if x == item)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(lst, tuple):\n    return sum(1 for i in tuple for j in lst if i == j)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(lst, sublst):\n    return sum(1 for x in lst for y in sublst if x==y)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(tuple1, lst):\n    return sum(1 for elem in tuple1 for element in lst if elem == element)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(t, lst):\n    return sum(1 for x in t for y in lst if x == y)", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(t, lst):\n    counts = {i: t.count(i) for i in set(t)}\n    return sum([counts.get(i, 0) for i in lst])", "matching_cluster_idx": 3}, {"solution": "def count_Occurrence(tuple, element_list):\n    return sum(1 for element in tuple for e in element_list if element in tuple and e == element)", "matching_cluster_idx": -1}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 91.0, "profiled": [{"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    Args:\n    s (str): The input string.\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [i[::-1] for i in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [str(item)[::-1] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [str(s)[::-1] for s in string_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 84.42307692307692, "dps_norm": 94.0, "pass@1": 99.0, "profiled": [{"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(listOfSublists):\n    return [sublist[0] for sublist in listOfSublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [lst[0] for lst in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [x[0] for x in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(listOfLists):\n    return [sublist[0] for sublist in listOfLists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_sublists):\n    return [sublist[0] for sublist in list_of_sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lists):\n    return [lst[0] for lst in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    return [i[0] for i in nested_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(lists):\n    return [i[0] for i in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [i[0] for i in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n    return [x[0] for x in list_of_lists]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def replace_char(s, char1, char2):\n    return s.replace(char1, char2)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char_to_replace, replacement):\n    return s.replace(char_to_replace, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char1, char2):\n    return s.replace(char1, char2)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char, repl):\n    return s.replace(char, repl)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char, replacement):\n    return s.replace(char, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char1, char2):\n    return s.replace(char1, char2)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char_to_replace, char_replacement):\n    return s.replace(char_to_replace, char_replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, char_to_replace_with):\n    return input_str.replace(char_to_replace, char_to_replace_with)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 96.20805369127517, "dps_norm": 97.5, "pass@1": 25.0, "profiled": [{"solution": "def big_sum(lst):\n    return max(lst) + min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    max_val = min_val = arr[0]\n    for i in arr[1:]:\n        if i > max_val:\n            max_val = i\n        if i < min_val:\n            min_val = i\n    return max_val + min_val", "matching_cluster_idx": 2}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return sum([max(arr)] + [min(arr)])", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    if len(lst) == 0:\n        return None\n    else:\n        return max(lst) + min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 63.15378610460578, "dps_norm": 72.72727272727272, "pass@1": 14.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    result = []\n    start = False\n    output = ''\n    for char in s:\n        if char == '\"':\n            if start:\n                result.append(output)\n                output = ''\n                start = False\n            else:\n                start = True\n        elif start:\n            output += char\n    return result", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    values = []\n    start = -1\n    temp = ''\n    for i in range(len(s)):\n        if s[i] == '\"':\n            if start == -1:\n                start = i\n            elif s[i] == '\"':\n                values.append(s[start+1:i].replace('\\\\', ''))\n                start = -1\n    return values", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    result = []\n    start = -1\n    for i, char in enumerate(s):\n        if char == '\"':\n            if start == -1:\n                start = i\n            elif start != -1:\n                result.append(s[start+1:i])\n                start = -1\n    return result", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    result = []\n    start = -1\n    for i, char in enumerate(s):\n        if char == '\"':\n            if start == -1:\n                start = i\n            elif start != -1:\n                result.append(s[start + 1:i])\n                start = -1\n    return result if result else []", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    result = []\n    temp = ''\n    inside_quotes = False\n    for char in s:\n        if char == '\"':\n            if not inside_quotes:\n                inside_quotes = True\n            else:\n                inside_quotes = False\n                result.append(temp)\n                temp = ''\n        elif inside_quotes:\n            temp += char\n    return [t.strip('\"') for t in result]", "matching_cluster_idx": 5}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/578": {"dps": 78.84126984126983, "dps_norm": 68.63636363636364, "pass@1": 78.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    return [x for t in zip(list1, list2, list3) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    return [val for sub_list in zip(*args) for val in sub_list]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*lists):\n    return [item for t in zip(*lists) for item in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*lists):\n    result = []\n    min_length = min(len(lst) for lst in lists)\n    for i in range(min_length):\n        for lst in lists:\n            result.append(lst[i])\n    for lst in lists:\n        result.extend(lst[min_length:])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for tuple_set in zip(list1, list2, list3) for val in tuple_set]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*args):\n    if not all(len(arg) == len(args[0]) for arg in args):\n        raise ValueError(\"All lists must be of the same length\")\n\n    return [x for t in zip(*args) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [x for t in zip(list1, list2, list3) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [x for t in zip(list1, list2, list3) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*lists):\n    result = []\n    for i in range(len(lists[0])):\n        for l in lists:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*lists):\n    return [item for t in zip(*lists) for item in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    if len(args) != 3:\n        raise ValueError(\"Exactly 3 lists are required\")\n    result = []\n    for a, b, c in zip(*args):\n        result.extend([a, b, c])\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    result = []\n    min_len = min(len(arg) for arg in args)\n    for i in range(min_len):\n        for arg in args:\n            result.append(arg[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*args):\n    if len(set(len(lst) for lst in args)) != 1:\n        raise ValueError(\"All lists must be of the same length\")\n    result = []\n    for i in range(len(args[0])):\n        for lst in args:\n            result.append(lst[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*args):\n    return [item for tup in zip(*args) for item in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for t in zip(list1, list2, list3) for item in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        if i < len(list2):\n            result.append(list2[i])\n        if i < len(list3):\n            result.append(list3[i])\n    return result", "matching_cluster_idx": 5}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [x for t in zip(list1, list2, list3) for x in t]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 59.0, "profiled": [{"solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    first_half = arr[:n]\n    second_half = arr[n:]\n    return second_half + first_half", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if len(arr) <= n:\n        return arr\n    else:\n        return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n > len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(Arr, n):\n    return Arr[n:] + Arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:]+arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    n = n - 1\n    return arr[n + 1:] + arr[:n + 1]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    arr = arr[n:] + arr[:n]\n    return arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:]+arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    return arr[n:]+arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:]+arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr\n    else:\n        return arr[n:]+arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/588": {"dps": 68.46330275229357, "dps_norm": 90.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    if len(lst) < 2:\n        return None\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    if len(nums) < 2:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    if len(lst) < 2:\n        return \"List must contain at least two numbers\"\n    else:\n        return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/597": {"dps": 77.95637198622273, "dps_norm": 94.23076923076923, "pass@1": 13.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    combined = sorted(arr1 + arr2)\n    return combined[k-1]", "matching_cluster_idx": 2}, {"solution": "def find_kth(arr1, arr2, k):\n    # merge two sorted arrays into one\n    merged_array = sorted(arr1 + arr2)\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(lst1, lst2, k):\n    merged = sorted(lst1 + lst2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays and sort them\n    merged = sorted(arr1 + arr2)\n    # Return the kth element\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    combined = sorted(arr1 + arr2)\n    return combined[k-1]", "matching_cluster_idx": 2}, {"solution": "def find_kth(nums1, nums2, k):\n    # Combine the two arrays and sort them\n    combined = sorted(nums1 + nums2)\n    # Return the kth element\n    return combined[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    merge = sorted(nums1 + nums2)\n    return merge[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    return sorted([*nums1, *nums2])[k-1]", "matching_cluster_idx": 2}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two arrays into one array\n    combined = arr1 + arr2\n    # Sort the combined array\n    combined.sort()\n    # Return the kth element (k-1) because array indices in Python start at 0\n    return combined[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # merge the two sorted arrays\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    if k > len(merged):\n        return -1\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    combined = arr1 + arr2\n    combined.sort()\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 23.636363636363637, "dps_norm": 84.0, "pass@1": 10.0, "profiled": [{"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    words = input_str.split() # Split the string into a list of words\n    reversed_words = words[::-1] # Reverse the list using slicing\n    return ' '.join(reversed_words) # Join the reversed list into a string with spaces in between", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()  # Splits the input string into a list of words\n    reversed_words = ' '.join(reversed(words))  # Reverses the order of the words and joins them back into a string\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()  # split the input string into a list of words\n    return ' '.join(reversed(words))  # join the words with a space, but in reverse order", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    return ' '.join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    words = s.split()  # split the string into words\n    reversed_words = \" \".join(reversed(words))  # reverse the words\n    return reversed_words", "matching_cluster_idx": 3}]}, "Mbpp/610": {"dps": 68.40579710144928, "dps_norm": 69.28571428571429, "pass@1": 31.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    if k > len(lst):\n        raise ValueError(\"k is larger than the length of the list\")\n\n    lst.pop(k - 1)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst,k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    lst.pop(k - 1)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1]+lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    lst.pop(k-1)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst,k):\n    return lst[:k-1]+lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k <= len(lst):\n        lst.pop(k-1)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    if k > len(lst):\n        return \"Invalid input. k is larger than the length of the list.\"\n    if k < 1:\n        return \"Invalid input. k must be a positive integer.\"\n    if k > 0:\n        return lst[:k-1] + lst[k:]\n    else:\n        return \"Invalid input. k must be a positive integer.\"", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst,k):\n    return lst[:k-1]+lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    kth_element = lst.pop(k-1)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    lst.pop(k-1)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    if k > len(lst):\n        return \"k is larger than the length of the list\"\n    else:\n        return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k > len(lst):\n        return \"Invalid operation: k is larger than the list length.\"\n    elif k == len(lst):\n        return lst[:-1]\n    elif k < 1:\n        return lst\n    else:\n        return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst,k):\n    return lst[:k-1]+lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 23.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(map(lambda x: x[n], matrix))", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(map(lambda x: x[n], matrix))", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or not matrix[0]:\n        return None\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or not matrix[0]:\n        return None\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(lst, n):\n    return max(x[n] for x in lst)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix:\n        return None\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 15.0, "profiled": [{"solution": "def move_zero(lst):\n    return [x for x in lst if x != 0] + [x for x in lst if x == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    zero = 0\n    for i in range(len(lst)):\n        if lst[i] != 0:\n            lst[zero], lst[i] = lst[i], lst[zero]\n            zero += 1\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zeros = [i for i in lst if i != 0]\n    zeros = [i for i in lst if i == 0]\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [x for x in lst if x != 0] + [x for x in lst if x == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    not_zero = [num for num in nums if num != 0]\n    return not_zero + [0] * (len(nums) - len(not_zero))", "matching_cluster_idx": 6}, {"solution": "def move_zero(list1):\n    result = [i for i in list1 if i != 0] + [0] * list1.count(0)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zeros = [i for i in lst if i != 0]\n    return non_zeros + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zero_elements = [i for i in lst if i != 0]\n    zero_elements = [i for i in lst if i == 0]\n    return non_zero_elements + zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zeros = [i for i in lst if i != 0]\n    zeros = [0] * (len(lst) - len(non_zeros))\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    return [num for num in nums if num != 0] + [0] * nums.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zero = [i for i in lst if i != 0]\n    zero = [i for i in lst if i == 0]\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    zeros = [i for i in lst if i == 0]\n    non_zeros = [i for i in lst if i != 0]\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    result = [x for x in lst if x != 0] + [0] * lst.count(0)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zero_elements = [element for element in lst if element != 0]\n    zero_count = len([element for element in lst if element == 0])\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/644": {"dps": 71.80851063829786, "dps_norm": 73.33333333333333, "pass@1": 98.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(input_array, k):\n    return input_array[:k][::-1] + input_array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(input_list, k):\n    return input_list[:k][::-1] + input_list[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return \"Invalid input. K is larger than the size of the array\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return arr\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 87.6923076923077, "dps_norm": 96.0, "pass@1": 91.0, "profiled": [{"solution": "def add_dict_to_tuple(a_tuple, a_dict):\n    return a_tuple + (a_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple, dictionary):\n    return tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_val, dictionary_val):\n    return tuple_val + (dictionary_val,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_value, dictionary):\n    return (*tuple_value, dictionary)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_obj, new_dict):\n    return (*tuple_obj, new_dict)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tuple_val, dictionary_val):\n    \"\"\"\n    This function adds a dictionary to a tuple.\n    Args:\n        tuple_val (tuple): The original tuple\n        dictionary_val (dict): The dictionary to be added to the tuple\n    Returns:\n        A new tuple containing the original elements and the dictionary\n    \"\"\"\n    return tuple_val + (dictionary_val,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, diction):\n    return tup + (diction,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    t += (d,)\n    return t", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return (*t, d)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tuple1, dictionary):\n    return (*tuple1, dictionary)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_a, dictionary):\n    return tuple_a + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d, )", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 60.245901639344254, "dps_norm": 65.0, "pass@1": 20.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\"[^\"]*?\"'\n    return [m.group(0).replace('\"', '') for m in re.finditer(pattern, s) if m]", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    result = []\n    quotation = \"\"\n    for char in s:\n        if char == '\"':\n            if quotation:\n                result.append(quotation[1:])\n                quotation = \"\"\n            else:\n                quotation = char\n        elif quotation:\n            quotation += char\n    return result\ns = \"Cortex \\\"A53\\\" Based \\\"multi\\\" tasking \\\"Processor\\\"\"", "matching_cluster_idx": 1}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    result = []\n    temp = \"\"\n    in_quotes = False\n    for char in s:\n        if char == '\"':\n            if not in_quotes:\n                in_quotes = True\n            else:\n                in_quotes = False\n                result.append(temp)\n                temp = \"\"\n        elif in_quotes:\n            temp += char\n    return result", "matching_cluster_idx": 2}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    result = []\n    start = False\n    temp = \"\"\n    for char in s:\n        if char == '\"':\n            if start:\n                result.append(temp)\n                temp = \"\"\n                start = False\n            else:\n                start = True\n        elif start:\n            temp += char\n    return result", "matching_cluster_idx": 2}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    result = []\n    start = -1\n    for i, char in enumerate(s):\n        if char == '\"':\n            if start == -1:\n                start = i\n            elif start != -1:\n                result.append(s[start+1:i])\n                start = -1\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 96.18217054263566, "dps_norm": 97.5, "pass@1": 88.0, "profiled": [{"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    return input_str.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = ''.join(char if char.isalnum() else ':' for char in s)\n    return s", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ',':').replace(',',':').replace('.',':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 80.2, "dps_norm": 65.55555555555556, "pass@1": 34.0, "profiled": [{"solution": "def tuple_to_dict(t):\n    dict = {}\n    for i in range(0, len(t), 2):\n        dict[t[i]] = t[i + 1]\n    return dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError('The length of the tuple must be even')\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i + 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have even number of elements\")\n    d = {}\n    for i in range(0, len(t), 2):\n        if i + 1 < len(t):\n            d[t[i]] = t[i + 1]\n    return d", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(t):\n    dict = {}\n    for i in range(0, len(t), 2):\n        dict[t[i]] = t[i+1]\n    return dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i + 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i + 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even\")\n    d = {}\n    for i in range(0, len(t), 2):\n        d[t[i]] = t[i+1]\n    return d", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    result = {}\n    for i in range(0, len(tup), 2):\n        key = tup[i]\n        value = tup[i+1]\n        result[key] = value\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        return {}\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even\")\n\n    d = {}\n    for i in range(0, len(t), 2):\n        key = t[i]\n        value = t[i+1]\n        d[key] = value\n    return d", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    result = {}\n    for i in range(0, len(t), 2):\n        key = t[i]\n        result[key] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple should have even number of elements\")\n    d = {}\n    for i in range(0, len(t), 2):\n        d[t[i]] = t[i+1]\n    return d", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements\")\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 37.32876712328767, "dps_norm": 52.5, "pass@1": 98.0, "profiled": [{"solution": "def check_none(tuple):\n    return any(type(i) == type(None) for i in tuple)", "matching_cluster_idx": 0}, {"solution": "def check_none(tup):\n    return any(x is None for x in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    return any(value is None for value in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    for i in t:\n        if i is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tuple_of_values):\n    return any(value is None for value in tuple_of_values)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return any(i is None for i in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    return any(x is None for x in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    return any(isinstance(x, type(None)) for x in tup)", "matching_cluster_idx": -1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple has any 'None' value or not.\n\n    Args:\n        tup (tuple): Input tuple to check for 'None' values.\n\n    Returns:\n        bool: True if tuple contains any 'None' values, False otherwise.\n    \"\"\"\n    return any(val is None for val in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return any(x is None for x in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(tuple1):\n    for item in tuple1:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tup):\n    return any(i is None for i in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    return any(x is None for x in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return any(value is None for value in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return any(val is None for val in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return any(x is None for x in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    return any(i is None for i in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tuple_variable):\n    for i in tuple_variable:\n        if i is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(args):\n    for arg in args:\n        if arg is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(t):\n    return any(x is None for x in t)", "matching_cluster_idx": 2}]}, "Mbpp/750": {"dps": 38.02721088435374, "dps_norm": 46.66666666666667, "pass@1": 99.0, "profiled": [{"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(input_list, given_tuple):\n    return input_list + list(given_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tuple_to_add):\n    return list(lst) + list(tuple_to_add)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, t):\n    lst.extend(t)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(input_list, input_tuple):\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(input_list, input_tuple):\n    input_list.extend(list(input_tuple))\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    return list(input_list) + list(input_tuple)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"Add the given tuple to the given list.\"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tup):\n    lst += list(tup)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, t):\n    return lst + list(t)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(the_list, tuple):\n    \"\"\"\n    This function adds the elements of the given tuple to the given list.\n    \n    Args:\n        the_list (list): The list to which we are adding elements.\n        tuple: The tuple from which we are adding elements.\n\n    Returns:\n        list: The list with the elements of the tuple added.\n    \"\"\"\n    the_list.extend(list(tuple))\n    return the_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, given_tuple):\n    return input_list + list(given_tuple)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 84.0, "profiled": [{"solution": "def min_k(tuples, k):\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    min_k_tuples = sorted(tuple_list, key=lambda x: x[1])[:k]\n    return min_k_tuples", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    lst.sort(key = lambda x: x[1])\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(record_list, k):\n    return sorted(record_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(record_tuple_list, k):\n    return sorted(record_tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(record_list, k):\n    return sorted(record_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(record, k):\n    return sorted(record, key = lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    sorted_tuple_list = sorted(tuple_list, key=lambda x: x[1])\n    return sorted_tuple_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    records.sort(key = lambda x: x[1])  # sort the list based on the second element of each tuple\n    return records[:k]  # return the first 'k' elements of the sorted list", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    sorted_tuples = sorted(tuple_list, key=lambda x: x[1])\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    return sorted(tuple_list, key = lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(rec, k):\n    return sorted(rec, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    lst.sort(key=lambda x: x[1])\n    return lst[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 60.775862068965516, "dps_norm": 78.125, "pass@1": 12.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    return [x for x,y,z in zip(l1,l2,l3) if x==y==z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(list1, list2, list3):\n    result = []\n    for index in range(len(list1)):\n        if index < len(list2) and index < len(list3):\n            if list1[index] == list2[index] == list3[index]:\n                result.append(list1[index])\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(list1, list2, list3):\n    max_len = max(len(list1), len(list2), len(list3))\n    common_elements = []\n    for i in range(max_len):\n        if i < len(list1) and i < len(list2) and i < len(list3):\n            if list1[i] == list2[i] == list3[i]:\n                common_elements.append(list1[i])\n    return common_elements", "matching_cluster_idx": 3}, {"solution": "def extract_index_list(lst1, lst2, lst3):\n    max_len = min(len(lst1), len(lst2), len(lst3))\n    result = []\n    for i in range(max_len):\n        if lst1[i] == lst2[i] == lst3[i]:\n            result.append(lst1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = [i for i in zip(l1, l2, l3) if i[0] == i[1] == i[2]]\n    return [i[0] for i in result]", "matching_cluster_idx": 5}, {"solution": "def extract_index_list(list1, list2, list3):\n    return [x for x, y, z in zip(list1, list2, list3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(list1, list2, list3):\n    length = min(len(list1), len(list2), len(list3))\n    common_elements = []\n    for i in range(length):\n        if list1[i] == list2[i] == list3[i]:\n            common_elements.append(list1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    zipped_list = zip(l1, l2, l3)\n    common_elements = [i for i in zipped_list if i[0] == i[1] == i[2] and i[0] is not None]\n    return [i[0] for i in common_elements]", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    i = 0\n    result = []\n    while i < len(l1) and i < len(l2) and i < len(l3):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n        i += 1\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_index_list(list1, list2, list3):\n    common_elements = [i for i in zip(list1, list2, list3) if i[0] == i[1] == i[2]]\n    return [element for element, _, _ in common_elements]", "matching_cluster_idx": 5}]}, "Mbpp/755": {"dps": 93.6283185840708, "dps_norm": 96.66666666666667, "pass@1": 25.0, "profiled": [{"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()\n    if len(nums) < 2:\n        return None\n    else:\n        return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = sorted(set(lst))\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = sorted(set(lst))\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates and sort the list\n    sorted_list = sorted(set(lst))\n    # If the list has less than 2 elements, it cannot have a second smallest number\n    if len(sorted_list) < 2:\n        return None\n    # Return the second smallest number\n    return sorted_list[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = list(set(lst)) # Remove duplicates and convert to list\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    numbers = list(set(numbers))  # remove duplicates and convert to a list\n    numbers.sort()\n    if len(numbers) < 2:\n        return None\n    return numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = list(set(lst))  # Remove duplicates\n    lst.sort()\n    return lst[1] if len(lst) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None\n    nums = sorted(set(nums))  # Remove duplicates and sort the list\n    if len(nums) < 2:\n        return None\n    return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates and sort the list\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers in the list\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None\n    smallest = min(nums)\n    if len(set(nums)) == 1:\n        return None\n    return min([x for x in nums if x != smallest])", "matching_cluster_idx": 2}, {"solution": "def second_smallest(lst):\n    lst = sorted(set(lst))\n    return lst[1] if len(lst) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))\n    nums.sort()\n    if len(nums) < 2:\n        return None\n    return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    if len(set(lst)) <= 1:\n        return None\n    return sorted(set(lst))[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(arr):\n    arr = list(set(arr)) # Remove duplicates\n    arr.sort()\n    if len(arr) < 2:\n        return None\n    return arr[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Remove duplicates, sort the list, and check if there's only one unique number\n    nums = list(set(nums))\n    nums.sort()\n    if len(nums) < 2:\n        return None\n    return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = sorted(set(lst))\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = sorted(set(nums))\n    if len(nums) < 2:\n        return None\n    return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))\n    nums.sort()\n    if len(nums) < 2:\n        return None\n    else:\n        return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = sorted(set(lst))\n    if len(lst) < 2:\n        return None\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = list(set(lst))  # remove duplicates and sort\n    if len(lst) < 2:\n        return None\n    lst.sort()\n    return lst[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": 79.55607476635514, "dps_norm": 22.692307692307693, "pass@1": 32.0, "profiled": [{"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if is_reverse(strings[i], strings[j]):\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(x, y):\n        return x == y[::-1]\n\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    pairs = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    def is_reverse(x, y):\n        return str(x) == str(y)[::-1]\n\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if is_reverse(lst[i], lst[j]):\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    count = 0\n    for i in range(len(word_list)):\n        for j in range(i+1, len(word_list)):\n            if word_list[i] == word_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 39.0, "profiled": [{"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1 or all(x == lst[0] for x in lst)", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1 or all(i == lst[0] for i in lst)", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 30.0, "profiled": [{"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return len([c for c in s if c.isdigit()])", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 55.14018691588785, "dps_norm": 54.166666666666664, "pass@1": 45.0, "profiled": [{"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst)):\n        if i < len(lst)-1:\n            result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 1}, {"solution": "def pair_wise(lst):\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i + 1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(x, y) for x, y in zip(lst, lst[1:])]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        if lst[i] == lst[i+1]:\n            result.append((lst[i], lst[i+1]))\n        else:\n            result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 1}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    result = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1) if i < len(lst)-1]", "matching_cluster_idx": 1}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n    result = [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]\n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i+1]))\n    return pairs", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 54.0235294117647, "dps_norm": 40.33613445378151, "pass@1": 17.0, "profiled": [{"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst)) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(i % 2 != 0 and isinstance(lst[i], int) and lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(n % 2 != 0 for i, n in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(i%2 != 0 and isinstance(i, int) for i in lst[1::2])", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(num % 2 != 0 for i, num in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all([i % 2 != 0 and isinstance(x, int) and x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def odd_position(lst):\n    return all(x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(num % 2 != 0 for i, num in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(i % 2 != 0 and isinstance(num, int) and num % 2 != 0 for i, num in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def odd_position(lst):\n    return all(num % 2 != 0 for i, num in enumerate(lst) if i % 2 != 0 and isinstance(num, int))", "matching_cluster_idx": 1}, {"solution": "def odd_position(lst):\n    for i, num in enumerate(lst):\n        if i % 2 != 0 and num % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(i % 2 != 0 and type(i) == int and i % 2 != 0 for i in lst[1::2])", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(i % 2 != 0 and isinstance(x, int) and x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 0}]}, "Mbpp/777": {"dps": 95.0, "dps_norm": 95.0, "pass@1": 38.0, "profiled": [{"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    lst = list(set(lst)) # Remove duplicates\n    sum_non_repeated = sum([i for i in lst if lst.count(i) == 1]) # Find the sum of non-repeated elements\n    return sum_non_repeated", "matching_cluster_idx": -1}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    lst = set(lst)  # remove duplicates\n    return sum(lst)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))  # This function will remove duplicates and then sum the elements in the list.", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    return sum(set(nums))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    return sum(set(nums))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 16.259842519685037, "dps_norm": 22.0, "pass@1": 98.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    divisors = [i for i in range(1, n+1) if n % i == 0]\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    return n in [x for x in range(1, n+1) if n % x == 0] and len([x for x in range(1, n+1) if n % x == 0]) % 2 == 0", "matching_cluster_idx": -1}, {"solution": "def count_divisors(n):\n    def count(n):\n        count = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                count += 1\n        return count\n    return count(n) % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the count of divisors is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    def count(n):\n        count = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                count += 1\n        return count\n\n    return count(n) % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns whether the count of divisors of the input number n is even or not.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    if n < 1:\n        return \"Input should be a positive integer\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 92.0, "profiled": [{"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 75.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=lambda x: sum(x))", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_sum = float('-inf')\n    max_list = None\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key = sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=lambda x: sum(x))", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key = sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 96.40350877192982, "dps_norm": 98.33333333333333, "pass@1": 95.0, "profiled": [{"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_nums, k):\n    return k in tuple_nums", "matching_cluster_idx": 5}, {"solution": "def check_K(lst, k):\n    return k in lst", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    for i in tuples:\n        if i == k:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}]}}}
